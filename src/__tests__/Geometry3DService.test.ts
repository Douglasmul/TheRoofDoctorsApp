/**
 * @fileoverview Tests for 3D Geometry Service
 * @version 1.0.0
 */

import { Geometry3DService } from '../services/Geometry3DService';
import { RoofPlane, ARPoint } from '../types/measurement';

// Mock data for testing
const mockARPoint = (x: number, y: number, z: number): ARPoint => ({
  x,
  y,
  z,
  confidence: 0.9,
  timestamp: new Date(),
  sensorAccuracy: 'high',
});

const mockRoofPlane: RoofPlane = {
  id: 'test_plane_1',
  boundaries: [
    mockARPoint(0, 0, 0),
    mockARPoint(5, 0, 0),
    mockARPoint(5, 0, 3),
    mockARPoint(0, 0, 3),
  ],
  normal: { x: 0, y: 1, z: 0 },
  pitchAngle: 30,
  azimuthAngle: 180,
  area: 15,
  perimeter: 16,
  projectedArea: 15,
  type: 'primary',
  confidence: 0.85,
  material: 'shingle',
};

describe('Geometry3DService', () => {
  let service: Geometry3DService;

  beforeEach(() => {
    service = new Geometry3DService();
  });

  afterEach(() => {
    service.clearCache();
  });

  describe('RoofPlane to Geometry Conversion', () => {
    it('should convert a RoofPlane to 3D geometry', () => {
      const geometry = service.convertPlaneToGeometry(mockRoofPlane);

      expect(geometry).toBeDefined();
      expect(geometry.id).toBe('geometry_test_plane_1');
      expect(geometry.roofPlaneId).toBe('test_plane_1');
      expect(geometry.vertices.length).toBeGreaterThan(0);
      expect(geometry.faces.length).toBeGreaterThan(0);
      expect(geometry.materials.length).toBeGreaterThan(0);
      expect(geometry.metadata.isValid).toBe(true);
    });

    it('should create geometry with correct vertex count', () => {
      const geometry = service.convertPlaneToGeometry(mockRoofPlane);
      
      // Should have double the boundary points (top and bottom)
      expect(geometry.vertices.length).toBe(mockRoofPlane.boundaries.length * 2);
    });

    it('should apply material based on roof plane type', () => {
      const geometry = service.convertPlaneToGeometry(mockRoofPlane);
      
      expect(geometry.materials[0]).toBeDefined();
      expect(geometry.materials[0].type).toBe('shingle');
      expect(geometry.materials[0].name).toBe('Asphalt Shingle');
    });

    it('should handle custom extrusion height', () => {
      const customHeight = 0.5;
      const geometry = service.convertPlaneToGeometry(mockRoofPlane, {
        extrusionHeight: customHeight,
      });

      // Check that top vertices have the correct Y coordinate
      const topVertices = geometry.vertices.slice(mockRoofPlane.boundaries.length);
      topVertices.forEach(vertex => {
        expect(vertex.y).toBe(customHeight);
      });
    });
  });

  describe('Model Creation', () => {
    it('should convert multiple planes to a model', () => {
      const plane2: RoofPlane = {
        ...mockRoofPlane,
        id: 'test_plane_2',
        type: 'secondary',
        material: 'metal',
      };

      const model = service.convertPlanesToModel([mockRoofPlane, plane2]);

      expect(model).toBeDefined();
      expect(model.geometries.length).toBe(2);
      expect(model.metadata.totalGeometries).toBe(2);
      expect(model.metadata.totalVertices).toBeGreaterThan(0);
      expect(model.metadata.totalFaces).toBeGreaterThan(0);
    });

    it('should apply auto-materials correctly', () => {
      const model = service.convertPlanesToModel([mockRoofPlane], {
        autoMaterials: true,
      });

      expect(model.geometries[0].materials[0].type).toBe('shingle');
    });
  });

  describe('Sample Geometry Generation', () => {
    it('should generate valid sample geometry', () => {
      const sampleGeometry = service.generateSampleGeometry();

      expect(sampleGeometry).toBeDefined();
      expect(sampleGeometry.id).toBe('sample_gabled_roof');
      expect(sampleGeometry.vertices.length).toBeGreaterThan(0);
      expect(sampleGeometry.faces.length).toBeGreaterThan(0);
      expect(sampleGeometry.materials.length).toBeGreaterThan(0);
      expect(sampleGeometry.metadata.isValid).toBe(true);
      expect(sampleGeometry.metadata.source).toBe('generated');
    });
  });

  describe('Export Functionality', () => {
    it('should export geometry as JSON', async () => {
      const geometry = service.convertPlaneToGeometry(mockRoofPlane);
      const jsonData = await service.exportGeometry(geometry, 'json');

      expect(typeof jsonData).toBe('string');
      
      const parsed = JSON.parse(jsonData as string);
      expect(parsed.id).toBe(geometry.id);
      expect(parsed.vertices).toEqual(geometry.vertices);
    });

    it('should export geometry as OBJ', async () => {
      const geometry = service.convertPlaneToGeometry(mockRoofPlane);
      const objData = await service.exportGeometry(geometry, 'obj');

      expect(typeof objData).toBe('string');
      expect((objData as string)).toContain('# Generated by TheRoofDoctorsApp');
      expect((objData as string)).toContain('v '); // Vertices
      expect((objData as string)).toContain('f '); // Faces
    });

    it('should export model as JSON', async () => {
      const model = service.convertPlanesToModel([mockRoofPlane]);
      const jsonData = await service.exportModel(model, 'json');

      expect(typeof jsonData).toBe('string');
      
      const parsed = JSON.parse(jsonData as string);
      expect(parsed.id).toBe(model.id);
      expect(parsed.geometries.length).toBe(1);
    });
  });

  describe('Import Functionality', () => {
    it('should import geometry from JSON', async () => {
      const originalGeometry = service.convertPlaneToGeometry(mockRoofPlane);
      const jsonData = await service.exportGeometry(originalGeometry, 'json');
      
      const importedGeometry = await service.importGeometry(jsonData, 'json');

      expect(importedGeometry.id).toBe(originalGeometry.id);
      expect(importedGeometry.vertices.length).toBe(originalGeometry.vertices.length);
      expect(importedGeometry.faces.length).toBe(originalGeometry.faces.length);
    });

    it('should import model from JSON', async () => {
      const originalModel = service.convertPlanesToModel([mockRoofPlane]);
      const jsonData = await service.exportModel(originalModel, 'json');
      
      const importedModel = await service.importModel(jsonData, 'json');

      expect(importedModel.id).toBe(originalModel.id);
      expect(importedModel.geometries.length).toBe(originalModel.geometries.length);
    });
  });

  describe('Error Handling', () => {
    it('should handle invalid export format', async () => {
      const geometry = service.convertPlaneToGeometry(mockRoofPlane);
      
      await expect(
        service.exportGeometry(geometry, 'invalid' as any)
      ).rejects.toThrow('Export format invalid not yet implemented');
    });

    it('should handle invalid import format', async () => {
      await expect(
        service.importGeometry('{}', 'invalid' as any)
      ).rejects.toThrow('Import format invalid not yet implemented');
    });
  });

  describe('Caching', () => {
    it('should cache geometry conversions', () => {
      const geometry1 = service.convertPlaneToGeometry(mockRoofPlane);
      const geometry2 = service.convertPlaneToGeometry(mockRoofPlane);

      // Should return the same object (cached)
      expect(geometry1).toBe(geometry2);
    });

    it('should clear cache correctly', () => {
      service.convertPlaneToGeometry(mockRoofPlane);
      service.clearCache();
      
      // After clearing cache, should create new geometry
      const geometry = service.convertPlaneToGeometry(mockRoofPlane);
      expect(geometry).toBeDefined();
    });
  });
});
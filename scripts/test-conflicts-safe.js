#!/usr/bin/env node

/**
 * Safe Conflict Testing Tool - Creates conflicts in a test directory
 * This version doesn't overwrite the actual package.json files
 */

const fs = require('fs');
const path = require('path');

const SAMPLE_CONFLICTS = {
  'package.json': `{
  "name": "TheRoofDoctorsApp",
  "version": "1.0.0",
  "private": true,
  "main": "index.js",
  "scripts": {
<<<<<<< HEAD
    "test": "jest",
    "build": "expo build"
=======
    "test": "jest --coverage",
    "start": "expo start"
>>>>>>> main
  },
  "devDependencies": {
    "@react-native-community/cli": "latest",
<<<<<<< HEAD
    "@types/react-native": "^0.72.8",
    "typescript": "~5.8.3"
=======
    "@types/react-native": "^0.73.0",
    "typescript": "~5.9.0",
    "jest": "^29.0.0"
>>>>>>> main
  },
  "dependencies": {
    "@react-navigation/native": "^7.1.17",
    "@react-navigation/stack": "^7.4.7",
    "expo": "^53.0.20",
<<<<<<< HEAD
    "react-native-safe-area-context": "^5.6.0",
    "react-native-screens": "^4.14.1"
=======
    "react-native-safe-area-context": "^5.7.0",
    "react-native-screens": "^4.15.0",
    "react-native-gesture-handler": "^2.14.0"
>>>>>>> main
  }
}`,

  'package-lock.json': `{
  "name": "TheRoofDoctorsApp",
  "version": "1.0.0",
  "lockfileVersion": 3,
  "requires": true,
  "packages": {
    "": {
      "name": "TheRoofDoctorsApp",
      "version": "1.0.0",
      "dependencies": {
<<<<<<< HEAD
        "@react-navigation/native": "^7.1.17",
        "@react-navigation/stack": "^7.4.7"
=======
        "@react-navigation/native": "^7.1.18",
        "@react-navigation/stack": "^7.4.8"
>>>>>>> main
      }
    }
  }
}`,

  'yarn.lock': `# THIS IS AN AUTOGENERATED FILE. DO NOT EDIT THIS FILE DIRECTLY.
# yarn lockfile v1

"@react-navigation/native@^7.1.17":
<<<<<<< HEAD
  version "7.1.17"
  resolved "https://registry.npmjs.org/@react-navigation/native/-/native-7.1.17.tgz"
=======
  version "7.1.18"
  resolved "https://registry.npmjs.org/@react-navigation/native/-/native-7.1.18.tgz"
>>>>>>> main
  dependencies:
    "@react-navigation/core" "^7.1.1"`
};

class SafeConflictTester {
  constructor(projectRoot = process.cwd()) {
    this.projectRoot = projectRoot;
    this.testDir = path.join(projectRoot, 'test-conflicts');
  }

  /**
   * Create test directory with conflicted files
   */
  createTestEnvironment() {
    console.log('üß™ Creating safe test environment for conflict resolution...\n');
    
    // Create test directory
    if (!fs.existsSync(this.testDir)) {
      fs.mkdirSync(this.testDir, { recursive: true });
    }
    
    // Create conflicted files in test directory
    for (const [fileName, conflictedContent] of Object.entries(SAMPLE_CONFLICTS)) {
      const testFilePath = path.join(this.testDir, fileName);
      fs.writeFileSync(testFilePath, conflictedContent, 'utf8');
      console.log(`‚ùå Created conflicted ${fileName} in test directory`);
    }
    
    console.log(`\n‚úÖ Test environment created at: ${this.testDir}`);
    console.log('\nüîß To test conflict resolution:');
    console.log(`   node scripts/resolve-conflicts-standalone.js "${this.testDir}"`);
    console.log('\nüîÑ To clean up test environment:');
    console.log(`   node scripts/test-conflicts-safe.js --cleanup`);
  }

  /**
   * Clean up test environment
   */
  cleanupTestEnvironment() {
    console.log('üîÑ Cleaning up test environment...\n');
    
    if (fs.existsSync(this.testDir)) {
      // Remove all files in test directory
      const files = fs.readdirSync(this.testDir);
      for (const file of files) {
        const filePath = path.join(this.testDir, file);
        fs.unlinkSync(filePath);
        console.log(`üóëÔ∏è  Removed ${file}`);
      }
      
      // Remove test directory
      fs.rmdirSync(this.testDir);
      console.log(`üìÅ Removed test directory: ${this.testDir}`);
    } else {
      console.log('‚ö†Ô∏è  Test directory not found, nothing to clean up');
    }
    
    console.log('\n‚úÖ Test environment cleanup completed!');
  }

  /**
   * Demonstrate the full conflict resolution workflow
   */
  async demonstrateWorkflow() {
    console.log('üé≠ Demonstrating complete conflict resolution workflow...\n');
    
    try {
      // Step 1: Create test environment
      this.createTestEnvironment();
      
      console.log('\n‚è≥ Testing conflict resolution...');
      
      // Step 2: Run conflict resolution
      const StandaloneMergeConflictResolver = require('./resolve-conflicts-standalone.js');
      const resolver = new StandaloneMergeConflictResolver(this.testDir);
      const success = await resolver.resolveConflicts();
      
      if (success) {
        console.log('\nüéâ Conflict resolution workflow completed successfully!');
        
        // Step 3: Display resolved files
        console.log('\nüìÑ Resolved files:');
        for (const fileName of Object.keys(SAMPLE_CONFLICTS)) {
          const resolvedPath = path.join(this.testDir, fileName);
          if (fs.existsSync(resolvedPath)) {
            console.log(`\nüìù ${fileName}:`);
            const content = fs.readFileSync(resolvedPath, 'utf8');
            // Show first few lines of resolved content
            const lines = content.split('\n').slice(0, 15);
            console.log(lines.map(line => `   ${line}`).join('\n'));
            if (content.split('\n').length > 15) {
              console.log('   ... (truncated)');
            }
          }
        }
      } else {
        console.log('\n‚ùå Conflict resolution encountered issues');
      }
      
    } catch (error) {
      console.error('‚ùå Error during workflow demonstration:', error.message);
    }
  }
}

// CLI interface
if (require.main === module) {
  const tester = new SafeConflictTester();
  const isCleanup = process.argv.includes('--cleanup');
  const isDemonstration = process.argv.includes('--demo');
  
  if (isCleanup) {
    tester.cleanupTestEnvironment();
  } else if (isDemonstration) {
    tester.demonstrateWorkflow().catch(error => {
      console.error('‚ùå Error:', error.message);
      process.exit(1);
    });
  } else {
    tester.createTestEnvironment();
  }
}

module.exports = SafeConflictTester;